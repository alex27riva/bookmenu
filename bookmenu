#!/usr/bin/env bash

FORMAT="" # e.g. epub, mobi
QUIET="false" # true or false to hide or show progress bar
OUT="$HOME/Downloads" # path to save books
URL1="https://1lib.eu/s" # covers and info
URL2="http://library.lol/main" # download links
URL3="https://ipfs.io/ipfs" # final upstream
INDEX="/tmp/bookmenu_index"
LIST="/tmp/bookmenu_list"
TITLE="/tmp/bookmenu_title"
INFO="/tmp/bookmenu_info"
COVER="/tmp/bookmenu_cover"
IMAGE="/tmp/bookmenu_image"
TEXT="/tmp/bookmenu_text"

command -v chafa >/dev/null || { echo "missing \"chafa\" dependency"; exit 1; }

get_index() { curl -s "${URL1}/${QUERY}/?extension=$FORMAT" > $INDEX; }
get_list() { grep "data-src" $INDEX | cut -d'"' -f8 | sed '/^\//d' > $LIST; max=$(wc -l $LIST | cut -d' ' -f1); }
get_title() { grep "text-decoration" $INDEX | cut -d'>' -f2 | tail -n +3 | sed -e "s/...$//" > $TITLE; }
get_info() { grep 'MB\|KB' $INDEX | cut -d">" -f2 | cut -d"<" -f1 > $INFO; }
termset() { [[ $1 == "reset" ]] && { tput cnorm; stty echo; trap 2; } || { tput civis; stty -echo; trap '' 2; }; }
load() { clear; [[ $QUIET == "true" ]] && wget -q "$1" -O "$2" || wget "$1" -O "$2"; clear; }
prompt() { echo -ne "\n[${count}/${max}] $1 [d]ownload [q]uit\n"; }
display() { paste $1 $2; }

save() { echo "loading...";
        hashsum=$(cut -d'/' -f9 <<< $link | cut -d '.' -f1);
        upstream=$(grep $URL3 <<< "$(curl -s $URL2/"$hashsum")" | cut -d'"' -f2)
        echo $upstream; sleep 3
        [[ -z $upstream ]] && { fail=$count; down=0; return 1; }
        [[ -z $1 ]] && name=$hashsum || name=$1 # set filename to hashsum if user input is empty
        clear; load "$upstream" "$OUT/$name.${extension,,}"; }


banner() { clear; echo "                   ______ ______
                 _/      Y      \_
                // ~~ ~~ | ~~ ~  \\\\
               // ~ ~ ~~ | ~~~ ~~ \\\\
              //________.|.________\\\\
             '----------'-'----------'
                      BOOKMENU"; echo -e "\n$1\n"; }

main() {
        next=1; count=1; max=0; down=0; fail=0; size=0;
        rm $INDEX $LIST $TITLE $INFO $COVER $IMAGE $TEXT 2>/dev/null
        banner; read -p "search: " QUERY; echo "loading..."
        get_index; get_list; get_title; get_info
        if [[ -s $LIST ]]; then
                while :; do
                        let limit=$max+1
                        [[ $count == "$limit" ]] && break
                        space=$(( ($(tput cols)/2) - 1))
                        link=$(sed -n "${count}p" $LIST)
                        data=$(sed -n "${count}p" $INFO)
                        extension=$(cut -d"," -f1 <<< $data)
                        size=$(cut -d"," -f2 <<< $data)
                        sed -n "${count}p" $TITLE | sed -e "s/.\{${space}\}/&\n/g" > $TEXT
                        echo -e "\nFormat: $extension\nSize:$size" >> $TEXT
                        load $link $COVER; chafa $COVER > $IMAGE; termset; display $IMAGE $TEXT
                        [[ $count == 1 ]] && prompt "[n]ext"
                        [[ $max == "$count" ]] && prompt "[p]reviouis"
                        [[ $count != 1 ]] && [[ $max != "$count" ]] && prompt "[p]revious [n]ext"
                        [[ $fail == "$count" ]] && echo "ipfs download unavailable for this book"
                        [[ $down == "$count" ]] && echo "saved to: \"$OUT/$name.$extension\""
                        while :; do
                                read -N 1 -s choice
                                case $choice in
                                        n)
                                        [[ $max != $count ]] && break;;
                                        p)
                                        [[ $count != 1 ]] && { next=0; let count--; break; }
                                        ;;
                                        d)
                                        termset reset; read -p "filename: " filename; save "$filename"; termset
                                        [[ $fail == 0 ]] && down=$count; next=0; break;;
                                        q)
                                        end=1; break;;
                                        *)
                                        ;;
                                esac
                        done
                [[ $end == 1 ]] && break; [[ $next == 1 ]] && let count++
                next=1; clear; done
        fi
        termset reset
        [[ $end != 1 ]] && [[ $count == 1 ]] && { banner "\n\nno books found"; exit 1; } || clear
}

main
